// generated by a tool
// common add/edit components
import React, { Component } from 'react';
import { Formik, Field, Form, ErrorMessage, FormikErrors, getIn, FormikProps } from 'formik';
import queryString from 'query-string';
import { History } from 'history';
import { ErrorControl } from '../../controls/error-control';
import { Loading } from '../../controls/loading';
import {AnimateIn} from "../../controls/animate-in";
import { Redirect } from 'react-router-dom'
import {Button, FormControlLabel, FormGroup, Rating, TextField} from "@mui/material";
import {TriStateCheckbox} from "../../controls/TriStateCheckbox";
import { DateTimePicker } from '@mui/lab';

// sub-components for {{cs_name Name}} 
import { {{cs_name Name}} } from './{{cs_name Name}}';
import { {{ClientApiInterfaceName}}, {{ClientApiTypeName}} } from './{{cml_case Name}}ApiClient';
import { {{cs_name Name}}Validate } from './{{cml_case Name}}Validate';
import {{cs_name Name}}{{OperationNameFriendly}}Rendering from './{{cml_case Name}}{{OperationNameFriendly}}Rendering';
{{#if CurrentOperation.UsesModel}}
import { {{cs_name Name}}{{OperationName}}Model } from "./{{cs_name Name}}{{OperationName}}Model";
{{/if}}
{{#each CurrentOperation.UserProvidedParameters}}
{{#if IsCustomTypeOrCustomArray}}
import { {{ResolvedTypescriptTypeUnderlying}} } from './{{ResolvedTypescriptTypeUnderlying}}'
{{/if}}
{{/each}}
{{#if IsUpdate}}
{{#if HasSelectAllType}}
import { {{cs_name SelectAllType.Name}} } from './{{cs_name SelectAllType.Name}}';
{{/if}}
{{/if}}
{{#if AssociateViaLink}}
    
// linking with other types    
import { linkedItem } from '../../linked-items';
{{#each LinkedDetails}}
import { {{LinkingType.ClientApiInterfaceName}}, {{LinkingType.ClientApiTypeName}} } from '../{{kb_case LinkingType.Name}}/{{cml_case LinkingType.Name}}ApiClient';
import { {{cs_name LinkingType.Name}}New } from '../{{kb_case LinkingType.Name}}/{{cs_name LinkingType.Name}}New';
{{/each}}
{{/if}}
{{#each CurrentOperation.ParameterReferenceTypes}}
import { {{cs_name Name}}Select } from '../{{kb_case Name}}/{{cml_case Name}}Select';
{{/each}}

export interface {{StateTypeName}} {
	{{#if CurrentOperation.UsesModel}}
    data: {{ModelTypeName}};
	{{#if IsUpdate}}
	fetched: {{cs_name SelectAllType.Name}} | null;
	{{/if}}
	{{else}}
	{{#each CurrentOperation.UserProvidedParameters}}
    {{cml_case Name}}: {{ResolvedTypescriptTypeUnderlying}} | null;
    {{/each}}
	{{/if}}
    error: boolean;
	message?: string | null;
	{{#if IsUpdate}}
	loading: boolean;	
	{{/if}}
}

export interface I{{cs_name Name}}{{OperationNameFriendly}}Props {
	history? : History;
	onSaved? (result: {{CurrentOperation.TypeScriptReturn}}) : void; 
	location? : any;
	title? : string;
	{{#if AssociateViaLink}}
	linkedType? : string;
	linkedId? : number | string | null;
	{{/if}}
	{{#if IsUpdate}}
	id?: {{get_ts_type IdentityField.ClrType}} | null;
	match?: any;
	{{/if}}
    {{#each CurrentOperation.EditableLinkingFields}}
    {{cml_case Name}} : {{get_ts_type ClrType}} | null;
    {{/each}}
    api? : {{ClientApiInterfaceName}} | null;
    {{#each LinkedDetails}}
    {{cml_case LinkingType.Name}}Client? : {{LinkingType.ClientApiInterfaceName}} | null;
    {{/each}}
}

export class {{cs_name Name}}{{OperationNameFriendly}} extends Component<I{{cs_name Name}}{{OperationNameFriendly}}Props,{{StateTypeName}}> {

    private api: {{ClientApiInterfaceName}} = this.props.api ? this.props.api : new {{ClientApiTypeName}}();
	private validation: {{cs_name Name}}Validate = new {{cs_name Name}}Validate();
	private rendering: {{cs_name Name}}{{OperationNameFriendly}}Rendering = new {{cs_name Name}}{{OperationNameFriendly}}Rendering();
	private qry: any = this.props && this.props.location ? queryString.parse(this.props.location.search) : null;

    constructor(props: I{{cs_name Name}}{{OperationNameFriendly}}Props) {
        super(props);
		{{#if IsUpdate}}
		var providedData = this.getProvidedData();
		{{/if}}

        this.state = {
			{{#if CurrentOperation.UsesModel}}			
			data: {{#if IsUpdate}}providedData ? providedData :{{/if}} {
				{{#each CurrentOperation.UserProvidedParameters}}
				{{#if RelatedTypeField.HasReferenceType}}
					{{#unless RelatedTypeField.ReferencesType.IsReferenceData}}
				{{cml_case Name}}: this.{{cml_case Name}},
					{{else}}
				{{cml_case Name}}: null,
					{{/unless}}
				{{else}}
				{{cml_case Name}}: null,
				{{/if}}
				{{/each}}			
			},
			{{#if IsUpdate}}
			fetched: null,
			{{/if}}
			{{else}}
			{{#each CurrentOperation.UserEditableParameters}}
			{{#if RelatedTypeField.HasReferenceType}}
			{{#unless RelatedTypeField.ReferencesType.IsReferenceData}}
			{{cml_case Name}}: this.{{cml_case Name}},
			{{else}}
			{{cml_case Name}}: null,
			{{/unless}}
			{{else}}
                {{#if IsCustomTypeOrCustomArray}}
            {{cml_case Name}}: {
                    {{#each ClientCustomType.Fields}}
                        {{#if HasReferenceType}}
                            {{#unless ReferencesType.IsReferenceData}}
                {{cml_case Name}}: this.{{cml_case Name}},
                            {{else}}
                {{cml_case Name}}: null,
                            {{/unless}}
                        {{else}}            
                {{cml_case Name}}: null,
                        {{/if}}    
                    {{/each}}   
            },
                {{else}}
             {{cml_case Name}}: null,
                {{/if}}
			{{/if}}
			{{/each}}
			{{/if}}
			{{#if IsUpdate}}
			loading: providedData == null,
			{{/if}}
			error: false
		};

		this.cancelSave = this.cancelSave.bind(this);
        this.handleSubmit = this.handleSubmit.bind(this);
		this.validate = this.validate.bind(this);
    }

	cancelSave(event: any){
		if (this.props.history) {
			this.props.history.goBack();		
		}
	}

    {{#each CurrentOperation.EditableLinkingFields}}
    get {{cml_case Name}}() : {{get_ts_type ClrType}} | null {
        if (this.props.{{cml_case Name}}){
            return this.props.{{cml_case Name}};
        }

        if (this.props.location.state && this.props.location.state.linkedType == "{{cml_case ReferencesType.Name}}") {
            return this.props.location.state.linkedId;
        }

        if (this.qry.{{cml_case Name}} && !Array.isArray(this.qry.{{cml_case Name}})) {
        {{#if IsInt}}
            return parseInt(this.qry.{{cml_case Name}});
        {{else}}
            return this.qry.{{cml_case Name}};
        {{/if}}
        }

        return null;
    }
	{{/each}}

	{{#if IsUpdate}}
	getProvidedData() : {{ModelTypeName}} | null {
		if (this.props.location.state && this.props.location.state.data){
			return this.props.location.state.data;
		}
		return null;
	}

	getId() : {{get_ts_type IdentityField.ClrType}} | null {
		if (this.props.id) {
			return this.props.id;
		}

		// get from uri
		if (this.props.match) {
			const { id } = this.props.match.params;
			if (id) {
				return id;
			}		
		}

		return null;
	}

	componentDidUpdate(): void {
        var id = this.getId();
		if (id && (id != this.state.data.id)) {
            this.getItemDetails(id);
        }
    }

	componentDidMount(): void {
        var id = this.getId();
		if (id && (id != this.state.data.id)) {
            this.getItemDetails(id);
        }
    }
	{{/if}}

	{{#if IsAttachment}}
    handleSubmit(fields : any) {
		var formData = new FormData();
		{{#each CurrentOperation.ClientSuppliedFields}}
		if (fields.{{NameWithPathCamelCase}}){
			{{#if Field.RelatedTypeField.IsFile}}
			formData.append('{{cml_case Name}}',fields.{{NameWithPathCamelCase}});		
			{{else}}
			formData.append('{{cml_case Name}}',fields.{{NameWithPathCamelCase}}.toString());		
			{{/if}}
		}
		{{/each}}
		this.api.{{cml_case OperationName}}(formData).then(data => {
			{{#unless IsUpdate}}
			if (data.parsedBody) {
                this.createLinkedItemAssociation(data.parsedBody);
            }
			{{/unless}}
			if (this.props.onSaved && data.parsedBody) {
                this.props.onSaved(data.parsedBody);
            } else if (this.props.history) {
                this.props.history.goBack();
            }
        }).catch(err => {
            err.text().then((value: string) => {
                this.setState({ error: true, message: value });
            });
        });
    }
	{{else}}
    handleSubmit(fields : any) {
        {{#if CurrentOperation.HasCustomType}}
        console.log(fields);
        {{/if}}
		{{#if CurrentOperation.UsesModel}}
		this.api.{{cml_case OperationName}}(fields).then(data => {
        {{else}}
            this.api.{{cml_case OperationName}}({{#each CurrentOperation.UserProvidedParameters}}{{#if IsCustomArrayType}}[fields.{{cml_case Name}}]{{else}}fields.{{cml_case Name}}{{/if}}{{#unless @last}}, {{/unless}}{{/each}}).then(data => { 
		{{/if}}
			{{#if AssociateViaLink}}
			if (data.parsedBody) {
                this.createLinkedItemAssociation(data.parsedBody);
            }
			{{/if}}
			if (this.props.onSaved && data.parsedBody) {
                this.props.onSaved(data.parsedBody);
            } else if (this.props.history) {
                this.props.history.goBack();
            }
        }).catch(err => {
            err.text().then((value: string) => {
                this.setState({ error: true, message: value });
            });
        });
    }
	{{/if}}

	validate(state: {{FormDataTypeName}}): FormikErrors<{{FormDataTypeName}}> {
        return this.validation.validate{{cs_name CurrentOperation.BareName}}(state);
    }

	{{#if AssociateViaLink}}
	createLinkedItemAssociation(id: number | string) {
		// creation via location from a link, or via linkedId and linkedType properties
        if (this.props.location || (this.props.linkedId && this.props.linkedType)) {
			
			var linked : [string, number | string] | null = null;
			if (this.props.linkedId && this.props.linkedType){
				linked = [this.props.linkedType, this.props.linkedId];
			} else {
				linked = linkedItem(this.props.location.state);			
			}

			if (linked) {
				{{#each LinkedDetails}}
				if (linked[0] == "{{Name}}") {
					var {{cml_case LinkingType.Name}}Client = this.props.{{cs_name LinkingType.Name}}Client ? this.props.{{cs_name LinkingType.Name}}Client : new {{LinkingType.ClientApiTypeName}}();
					var {{cml_case LinkingType.Name}}ToAdd: {{cs_name LinkingType.Name}}New = { {{cml_case LinkingTypeIdField.Name}}: linked[1] as {{get_ts_type LinkingTypeIdField.ClrType}}, {{cml_case CurrentTypeIdField.Name}}: id as {{get_ts_type CurrentTypeIdField.ClrType}} };
					{{cml_case LinkingType.Name}}Client.insert({{cml_case LinkingType.Name}}ToAdd);
				}
				{{/each}}
			}		
		}
    }
	{{/if}}

    hasError(key: string, formik: FormikProps<Readonly<{{FormDataTypeName}}>>){
        return getIn(formik.errors, key) && getIn(formik.touched, key);
    }

    render() {
        return (
		<AnimateIn>
		<Formik {{#if IsUpdate}}enableReinitialize{{/if}} initialValues={ {{CurrentOperation.StatePath}} } onSubmit={this.handleSubmit} validate={this.validate}>
            {formik => (
			<div>
                {this.renderTitle()}
				{{#if IsUpdate}} { this.state.loading ? <Loading /> : null } {{/if}}
				{ this.state.error ? <ErrorControl message={this.state.message ? this.state.message : ""} /> : null }
                <Form autoComplete="off">                        
					{{#each CurrentOperation.UserInputFields}}											
						{{#if IsBoolean}}
                        <FormGroup>
                            <FormControlLabel control={<TriStateCheckbox id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" checked={ formik.values.{{NameWithPathSafeCamelCase}} } onChange={(e:any) => {
                            formik.setFieldValue('{{NameWithPathCamelCase}}', e.target.checked);
                            }} />} label="{{#if Field.IsRequired}}*{{/if}}{{hmn Field}}" />
                            <ErrorMessage name="{{NameWithPathCamelCase}}" component="div" className="invalid-feedback" />
                        </FormGroup>
						{{else}}
						<div className="form-group row">
							<div className="col-sm-10">
							{{#if Field.HasReferenceType}}
							<Field id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" component={ {{cs_name Field.ReferencesType.Name}}Select } value={ {{../CurrentOperation.StatePath}}?.{{NameWithPathSafeCamelCase}} } label="{{hmn Field}}" {{#unless Field.ReferencesType.IsReferenceData}} error={ this.hasError('{{NameWithPathSafeCamelCase}}', formik)} readonly={this.{{cml_case Name}} != null} {{/unless}} />
							{{else}}
								{{#if IsDateTime}}
                                <DateTimePicker
                                    renderInput={(props) => <TextField id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" onBlur={formik.handleBlur} {{#if Field.IsRequired}}required={true}{{/if}} error={ this.hasError('{{NameWithPathCamelCase}}', formik)} {...props} />}
                                    label="{{hmn Field}}"
                                    {{#unless Field.IsRequired}}
                                    clearable={true}
                                    clearText="clear"
                                    {{/unless}}
                                    value={ formik.values.{{NameWithPathSafeCamelCase}} }
                                    onChange={(newValue) => {
                                        formik.setFieldValue("{{NameWithPathCamelCase}}", newValue);
                                    }}
                                />
								{{else}}
									{{#if IsLargeTextContent}}
                                <TextField id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" value={ formik.values.{{NameWithPathSafeCamelCase}} } onChange={formik.handleChange} onBlur={formik.handleBlur} label="{{hmn Field}}" {{#if Field.IsRequired}}required={true}{{/if}}  type="{{input_type ClrType}}" error={ this.hasError('{{NameWithPathCamelCase}}', formik)} placeholder="Enter {{hmn Name}}" multiline={true} maxRows={5} />
                                    {{else}}
									{{#if IsFile}}
								<input hidden type="file" id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" onChange={(event: any) => {
                                        formik.setFieldValue("{{NameWithPathCamelCase}}", event.currentTarget.files[0]);
                                }} />
                                        <label htmlFor="{{NameWithPathCamelCase}}">
                                            <Button variant="contained" component="span" color="primary">
                                                Choose {{hmn Name}}
                                            </Button>
                                            {formik.values.{{NameWithPathSafeCamelCase}}?.name}
                                        </label>
                                    {{else}}
										{{#if IsRating}}
								<Rating id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" value={ formik.values.{{NameWithPathSafeCamelCase}} } onChange={formik.handleChange} onBlur={formik.handleBlur}/>
										{{else}}
                                            {{#if IsColor}}
								<Field id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" type="color" className={'form-control' + (getIn(formik.errors, '{{NameWithPathCamelCase}}') && getIn(formik.touched, '{{NameWithPathCamelCase}}') ? ' is-invalid' : '')} placeholder="Enter {{hmn Name}}" />                                
										    {{else}}
								<TextField id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" value={ formik.values.{{NameWithPathSafeCamelCase}} } onChange={formik.handleChange} onBlur={formik.handleBlur} label="{{hmn Field}}" {{#if Field.IsRequired}}required={true}{{/if}}  type="{{input_type ClrType}}" error={ this.hasError('{{NameWithPathCamelCase}}', formik)} placeholder="Enter {{hmn Name}}" />                                
                                            {{/if}}    
                                        {{/if}}
									{{/if}}
									{{/if}}
								{{/if}}
							{{/if}}
							<ErrorMessage name="{{NameWithPathCamelCase}}" component="div" className="invalid-feedback" />
							</div>
						</div>
						{{/if}}						
					{{/each}}
					<div className="row">
						<div className="col-sm-10 offset-sm-2">
                            <Button color="primary" variant="contained" type="submit">Save</Button>
                            <Button variant="outlined" onClick={this.cancelSave}>Cancel</Button>
						</div>						
					</div>
                </Form>
            </div>
			)}
        </Formik>
		</AnimateIn>
        );
    }

	renderTitle() : JSX.Element | null {
		if (this.props.title){
			return <h1>{this.props.title}</h1>;
		}
		
		var customTitle = this.rendering.renderCustomTitle(this.state);
		if (customTitle){
			return customTitle;
		}

		return <h1>{{OperationNameFriendly}} {{hmn Name}}</h1>;
	}

	{{#if IsUpdate}}
	async getItemDetails(id: {{get_ts_type IdentityField.ClrType}}) {
        await this.api.selectForDisplayById(id).then(data => {
            if (data.parsedBody && data.parsedBody.length > 0) {
				var newData = {
					{{#each CurrentOperation.UserProvidedParameters}}
					{{#if IsFile}}
					{{cml_case Name}}: null,
					{{else}}
					{{cml_case Name}}: data.parsedBody[0].{{cml_case Name}},
					{{/if}}
					{{/each}}				
				}
				this.setState({ data: newData, loading: false, fetched: data.parsedBody[0] });								
			} else {
				this.setState({ loading: false, error: true, message: "Item Not Found" });				
			}            
        }).catch(err => {
            this.setState({ loading: false, error: true, message: err.message });
        });
    }
	{{/if}}
}