// generated by a tool
import React, { Component, RefObject } from 'react';
import { searchState } from '../../searchState';
import { Search, SearchProps } from '../../searchComponent';
import { {{ReturnTypeName}} } from './{{cs_name ReturnTypeName}}';
import { {{ReturnTypeName}}List } from './list/{{cml_case ReturnTypeName}}List';
import { {{ClientApi.ClientApiTypeName}}, {{ClientApi.ClientApiInterfaceName}} } from './{{cml_case RelatedType.Name}}ApiClient';

interface {{cs_name Name}}ComponentProps extends SearchProps {
    api: {{ClientApi.ClientApiInterfaceName}} | null;
    location: any;
    history: any;
}

export class {{cs_name Name}}Component extends Search<{{cs_name Name}}ComponentProps, {{ReturnTypeName}}> {

	private api : {{ClientApi.ClientApiInterfaceName}} = this.props.api ? this.props.api : new {{ClientApi.ClientApiTypeName}}();
	private input : RefObject<HTMLInputElement> = React.createRef<HTMLInputElement>();

	constructor(props: {{cs_name Name}}ComponentProps) {
        super(props);
		this.setSearchQuery = this.setSearchQuery.bind(this);
    }

	componentDidUpdate(prevProps: any) {
        super.componentDidUpdateBase(prevProps, this.input);
    }

	render() {
		return (
			<div>
				<h1>{{hmn RelatedType}} Search</h1>
				<input type='text' className='form-control' onChange={this.setSearchQuery} defaultValue={this.state.searchText ? this.state.searchText : ""} ref={this.input} />
				<{{ReturnTypeName}}List data={ this.state.data } hideHeading={true} {...this.props} />
			</div>
		);	
	}

	async performSearch() {
        await this.api.{{cml_case BareName}}(this.state.searchText).then(data => {
            var responseBody = data.parsedBody;
            if (responseBody) {
                this.setState({ data: responseBody, loading: false, error: false, message: null, searchText: this.state.searchText, loadingFromHistory: false } as Pick<searchState<{{ReturnTypeName}}>, keyof searchState<{{ReturnTypeName}}>>);
				this.addSearchHistory();
            } else {
                this.setState({ loading: false, error: false, message: "no results", searchText: this.state.searchText, loadingFromHistory: false } as Pick<searchState<{{ReturnTypeName}}>, keyof searchState<{{ReturnTypeName}}>>);     
            }
        }).catch(err => {
            this.setState({ data: [], loading: false, error: true, message: err.message });
        });
    }
}